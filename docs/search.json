[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introducción",
    "section": "",
    "text": "Librerías comunes:\n\n\nlibrary(datasets)\nlibrary(readxl)\nlibrary(readr)\nlibrary(tidyverse)\nlibrary(paletteer) # permite ver los colores en la consola\nlibrary(viridis) # para los colores magma\nlibrary(ggplot2)\nlibrary(glue)\nlibrary(scales) # función alpha que ajusta la transparencia\nlibrary(ggtext)"
  },
  {
    "objectID": "src/boxplot.html",
    "href": "src/boxplot.html",
    "title": "Boxplot",
    "section": "",
    "text": "Librerías específicas.\n\nCódigolibrary(palmerpenguins)\n\n\n\nCódigo# Crear el gráfico de caja\npenguins |&gt; ggplot(aes(x = species, y = body_mass_g, fill = sex)) +\n  geom_boxplot(outlier.color = \"yellow3\", outlier.shape = 16, outlier.size = 3) +  # personalización de outliers\n  scale_fill_manual(values = c(\"male\" = \"#FF6347\", \"female\" = \"#4682B4\"), na.value =\"white\") +\n  labs(\n    title = \"Distribución de la Masa Corporal por Especie y Sexo\",\n    subtitle = \"Pingüinos del archipiélago Palmer\",\n    x = \"Especie de Pingüino\",\n    y = \"Masa Corporal (g)\",\n    fill = \"Sexo\"\n  ) +\n  theme_classic(base_size = 10) +  # Tema clásico con tamaño de fuente base\n  theme(\n    plot.title = element_text(face = \"bold\", hjust = 0.5, size = 12),  # Título en negrita y centrado\n    plot.subtitle = element_text(hjust = 0.5, size = 12),  # Subtítulo centrado\n    axis.title = element_text(face = \"bold\"),  # Ejes en negrita\n    legend.position = \"right\",\n    panel.background = element_rect(fill = \"lightgray\")  # Fondo del panel en gris claro\n  )"
  },
  {
    "objectID": "src/word_cloud.html",
    "href": "src/word_cloud.html",
    "title": "Word cloud",
    "section": "",
    "text": "Word cloud de las primeras diez mil palabras del Quijote.\n\n\n\n\n\n\nINCLUIR LINK NLP\n\n\n\nIncluir link al repositorio de NLP\n\n\nLibrerías específicas.\n\nCódigolibrary(stringr)\nlibrary(wordcloud)\nlibrary(tm)\nlibrary(stopwords)\nlibrary(ggwordcloud)\n\n\n(Funcional paquete ‘wordcloud’)[https://cran.r-project.org/web/packages/wordcloud/wordcloud.pdf] (Más ejemplos de ggwordcloud)https://cran.r-project.org/web/packages/ggwordcloud/vignettes/ggwordcloud.html\nDatos.\nFuente: https://www.gutenberg.org/cache/epub/2000/pg2000.txt\nCódigo.\n\nCódigo# Leo el Quijote\nquijote &lt;- readLines(\"../data/quijote.txt\", encoding = \"UTF-8\")\n\n# Concateno todas las líneas en una sola cadena\nquijote &lt;- paste(quijote, collapse = \" \")\n\n# Convierto el Quijote a minúsculas, elimino caracteres especiales\nquijote &lt;- tolower(quijote)\nquijote &lt;- str_replace_all(quijote, \"[^a-záéíóúüñ]\", \" \")\n\n# Dividir el texto en palabras y eliminar stop words\nquijote_words &lt;- unlist(strsplit(quijote, \"\\\\s+\"))\nquijote_words &lt;- quijote_words[!quijote_words %in% tm::stopwords(\"spanish\")] # análogo: quijote_words &lt;- quijote_words[!quijote_words %in% stopwords::stopwords(\"spanish\")]\nquijote_words &lt;- quijote_words[!quijote_words %in% tm::stopwords(\"spanish\")]\n\n# Filtrar las palabras vacías (espacios en blanco) y obtener las primeras 1000 palabras\nquijote_words &lt;- quijote_words[quijote_words != \"\"]\nfirst_1000_words &lt;- quijote_words[1:10000]\n\n\n\nCódigowordcloud(words = first_1000_words, min.freq = 10, colors = brewer.pal(8, \"Dark2\"))\n\n\n\n\n\nCódigo# first_1000_words |&gt; table() |&gt; as.data.frame() |&gt; \n# ggplot(aes(label = first_1000_words, size = Freq)) +\n#   geom_text_wordcloud() +\n#   scale_size_area(max_size = 30) +\n#   theme_minimal()\n\n\n\nCódigodata(\"love_words_small\")"
  },
  {
    "objectID": "src/parlamento.html#parlamento-semicircular",
    "href": "src/parlamento.html#parlamento-semicircular",
    "title": "Diagrama de parlamento",
    "section": "Parlamento semicircular",
    "text": "Parlamento semicircular\nSe representa los votos recibidos por cada partido político en las elecciones de noviembre de 2019.\nEl número de escaños representado para cada partido político es proporcional a los votos recibidos y no representa el método D’Hondt.\nLibrerías específicas.\n\nCódigolibrary(ggparliament)\n\n\nDatos.\n\nCódigodatos_elecciones &lt;- read_csv(file = \"../data/datos_elecciones_brutos.csv\")\ndatos_elecciones &lt;- datos_elecciones |&gt; filter(anno==max(anno)) |&gt; filter(mes==max(mes))\n\n# Elimino variables sin información\ncols_sin_informacion &lt;- datos_elecciones |&gt; select(1:15) |&gt;\n  summarise(across(everything(), n_distinct)) |&gt; pivot_longer(cols = everything()) |&gt; \n  filter(value==1) |&gt; select(name) |&gt; pull()\n\ndatos_elecciones &lt;- datos_elecciones |&gt; select(-all_of(cols_sin_informacion))\n\n# Pivoto los datos\ndatos_elecciones &lt;- datos_elecciones |&gt;\n  pivot_longer(cols = -c(0:votos_candidaturas),\n               names_to = \"partido_politico\",\n               values_to = \"votos\") |&gt; \n  drop_na(votos)\n\n# Creo las siglas de cada partido y agrupo los votos por las siglas\nsource(\"../src/mutate_siglas.R\")\ndatos_elecciones &lt;- mutate_siglas(datos_elecciones)\n\ndatos_elecciones &lt;- datos_elecciones |&gt;\n  summarise(votos = sum(votos), .by=everything()[! everything() %in% c('votos')])\n\ndatos_elecciones &lt;- datos_elecciones |&gt;\n  mutate(siglas = fct_reorder(siglas, votos, .fun = sum))\n\n\n\nCódigo# Defino la paleta de colores\ndatos_elecciones &lt;- datos_elecciones |&gt;\n  mutate(color_politico = case_when(siglas == \"PP\" ~ \"#3399FF\",\n                         siglas == \"PSOE\" ~ \"#F6350B\",\n                         siglas == \"C's\" ~ \"#FF5824\",\n                         siglas == \"PNV\" ~ \"#008135\",\n                         siglas == \"BNG\" ~ \"#76b3dd\",\n                         siglas == \"COMPROMÍS\" ~ \"#de6c25\",\n                         siglas == \"CiU\" ~ \"#FF0000\",\n                         siglas == \"UP\" ~ \"#6D50B3\",\n                         siglas == \"ERC\" ~ \"#ffbf41\",\n                         siglas == \"EH - BILDU\" ~ \"#00bda1\",\n                         siglas == \"MÁS PAÍS\" ~ \"#E61455\",\n                         siglas == \"VOX\" ~ \"#73B446\",\n                         TRUE ~ \"#462B25\"))\n\n\nCódigo.\n\nCódigoparlamento &lt;- datos_elecciones |&gt; \n  summarise(votos=sum(votos), .by = c(siglas, color_politico))\n\nparlamento &lt;- parlamento |&gt; \n  mutate(asientos = round(350*votos/sum(votos))) |&gt; \n  select(-votos)\n\nsemicircle &lt;- parliament_data(election_data = parlamento,\n                                 type = \"semicircle\", # Tipo de parlamento\n                                 parl_rows = 7,      # Número de filas del parlamento\n                                 party_seats = parlamento$asientos) # Asientos por partido\n\nsemi2 &lt;- ggplot(semicircle, aes(x = x, y = y, colour = siglas)) +\n  geom_parliament_seats() + \n  theme_ggparliament() +\n  labs(title = \"Segundas elecciones de 2.019\", x = \"\", y = \"\") +\n  scale_colour_manual(values = semicircle$color_politico, \n                      limits = semicircle$siglas) + \n  theme(legend.position=\"bottom\")\n\nsemi2"
  },
  {
    "objectID": "src/grafico_dispersion.html#section",
    "href": "src/grafico_dispersion.html#section",
    "title": "Gráfico de dispersión",
    "section": "(1)",
    "text": "(1)\nLibrerías específicas.\n\nCódigolibrary(palmerpenguins)\n\n\nCódigo.\n\nCódigopenguins |&gt; ggplot(aes(x = bill_length_mm, y = bill_depth_mm, color = species)) + \n  geom_point(size = 2, alpha = 0.6) + \n  geom_smooth(method = \"lm\", se = FALSE, linetype = \"dashed\", color = \"black\") +  # Línea de regresión\n  geom_smooth(aes(group=species, color=species), method = \"lm\", se = FALSE, linetype = 6) +  # Línea de regresión por grupos\n  scale_color_manual(values = c(\"Adelie\" = \"#FF5733\", \"Chinstrap\" = \"#33FF57\", \"Gentoo\" = \"#3357FF\")) +  # Colores personalizados\n  labs(\n    title = \"Relación entre la longitud y la Profundidad del Pico de los Pingüinos\",\n    subtitle = \"Diferentes especies de pingüinos en el archipiélago Palmer\",\n    x = \"Longitud del Pico (mm)\",\n    y = \"Profundidad del Pico (mm)\",\n    color = \"Especie\"\n  ) +\n  theme_minimal(base_size = 8) +  # Tema minimalista con tamaño de fuente base\n  theme(\n    plot.title = element_text(face = \"bold\", hjust = 0.5, size = 12),\n    plot.subtitle = element_text(hjust = 0.5, size = 12),\n    axis.title = element_text(face = \"italic\"),  # ejes en cursiva\n    legend.position = \"top\",\n    legend.background = element_rect(fill = \"lightblue1\", color = \"blue\", size = 0.5),  # fondo y borde de la leyenda\n    panel.grid.major = element_line(color = \"gray80\")  # líneas de cuadrícula\n  )"
  },
  {
    "objectID": "src/grafico_dispersion.html#section-1",
    "href": "src/grafico_dispersion.html#section-1",
    "title": "Gráfico de dispersión",
    "section": "(2)",
    "text": "(2)\n\nCódigomtcars |&gt; ggplot(aes(x = wt, y = mpg, color = factor(cyl), shape = factor(gear))) +\n  geom_point(size = 4) +\n  scale_color_manual(values = c(\"red\", \"blue\", \"green\"),\n                     name = \"Cilindrada (cyl)\",\n                     labels = c(\"4 cilindros\", \"6 cilindros\", \"8 cilindros\")) + \n  scale_shape_manual(values = c(16, 17, 18),\n                     name = \"Engranaje (gear)\",\n                     labels = c(\"3 marchas\", \"4 marchas\", \"5 marchas\")) + \n  labs(title = \"Relación entre Peso y Consumo de Combustible\",\n       subtitle = \"Datos del conjunto mtcars\",\n       x = \"Peso (1000 lbs)\",\n       y = \"Millas por Galón (mpg)\",\n       caption = \"Fuente: Motor Trend Car Road Tests\") +\n  theme_minimal() +\n  theme(legend.position = \"bottom\",\n        legend.title = element_text(face = \"bold\", size = 8),\n        legend.text = element_text(size = 6),\n        legend.key = element_rect(fill = \"white\", color = \"black\"),  # Fondo de la leyenda blanco con borde negro\n        legend.background = element_rect(fill = \"lightgrey\", color = \"black\"),  # Fondo de la leyenda gris claro con borde negro\n        legend.box.background = element_rect(color = \"black\"))  # Borde negro alrededor de la caja de la leyenda"
  },
  {
    "objectID": "src/gatitos_inflaccion.html",
    "href": "src/gatitos_inflaccion.html",
    "title": "Gatitos e inflacción",
    "section": "",
    "text": "Librerías específicas.\n\nCódigolibrary(gganimate)\nlibrary(ggcats)\n\n\nDatos.\nwww.inflation.eu\n\nCódigoinflation &lt;- rbind(read_excel(\"../data/inflaccion.xlsx\", sheet = \"Spain\"),\n                   read_excel(\"../data/inflaccion.xlsx\", sheet = \"Italy\"))\n\ncolnames(inflation) &lt;- c('annyo','inflaccion','annyo','inflaccion')\ninflation &lt;- rbind(inflation[,c(1,2)],inflation[,c(3,4)])\n\ninflation[c('IPC', 'País', \"annyo\")] &lt;- str_split_fixed(inflation$annyo, \" \", 3)\ninflation &lt;- inflation |&gt; mutate(inflaccion = readr::parse_number(inflaccion)/100,\n                                 annyo = as.numeric(annyo))\n\n\nCódigo.\n\nCódigoinflation &lt;- inflation |&gt; mutate(gato = case_when(País == \"España\" ~ 'nyancat',\n                                      País == \"Italia\" ~ 'pop_close'))\n\ninflation |&gt; ggplot(aes(x = annyo, y = inflaccion, group = País, color = País)) +\n  geom_line(size = 0.5) +\n  geom_cat(aes(cat = gato), size = 1.5) +\n  xlab(\"Año\") +\n  ylab(\"Inflacción\") +\n  transition_reveal(annyo) +\n  scale_colour_discrete(\n    labels = function(x) {\n      ifelse(x == \"Other\", \"Other\", paste0(\"*\", x, \"*\"))\n    }\n  ) +\n  theme_minimal() +\n  theme(legend.text = element_markdown(), # Esto para conseguir usar la cursiva\n        legend.key = element_rect(fill = \"white\", color = \"black\"),\n        legend.background = element_rect(fill = \"lightgrey\", color = \"red\"),\n        legend.box.background = element_rect(color = \"black\"),\n        legend.title = element_text(face = \"italic\")) +\n  labs(title = \"Inflacción histórica anual de España e Italia\",\n              subtitle = \"Diciembre vs diciembre año anterior\",\n              caption = \"Fuente: www.inflation.eu\")"
  },
  {
    "objectID": "src/grafico_gannt.html",
    "href": "src/grafico_gannt.html",
    "title": "Gráfico de Gannt",
    "section": "",
    "text": "Gráfico de Gannt de un proceso de selección.\nSe tiene la fecha de inicio y de finalización de cada tarea. Para el status de cada tarea se compara la fecha actual con la fecha de finalización de la tarea.\nDatos\n\nCódigotasks &lt;- \n  data.frame(\n    task = factor(c(\"Revisión de CV\",\n                    \"Entrevista inicial\",\n                    \"Prueba técnica\",\n                    \"Llamar referencias\",\n                    \"Entrevista final\",\n                    \"Oferta\"),\n                  levels = c(\"Revisión de CV\",\n                             \"Entrevista inicial\",\n                             \"Prueba técnica\",\n                             \"Llamar referencias\",\n                             \"Entrevista final\",\n                             \"Oferta\")),\n    start = as.Date(c(\"2024-01-01\",\n                      \"2024-01-10\",\n                      \"2024-01-15\",\n                      \"2024-01-15\",\n                      \"2024-01-20\",\n                      \"2024-02-01\")),\n    end = as.Date(c(\"2024-01-07\",\n                    \"2024-01-15\",\n                    \"2024-01-25\",\n                    \"2024-01-16\",\n                    \"2024-02-05\",\n                    \"2024-02-15\"))\n)\n\ntasks &lt;- tasks %&gt;%\n  mutate(\n    # Sustituir la fecha por Sys.Date()\n    fecha_actual = \"2024-01-17\",\n    status = case_when(\n      start &gt; \"2024-01-17\" ~ \"planned\",\n      start &lt; \"2024-01-17\" & end &gt; \"2024-01-17\" ~ \"on track\",\n      start &lt; \"2024-01-17\" & end &lt; \"2024-01-17\" ~ \"done\",\n      TRUE ~ \"delayed\")\n  ) |&gt; arrange(start)\n\ntasks\n\n                task      start        end fecha_actual   status\n1     Revisión de CV 2024-01-01 2024-01-07   2024-01-17     done\n2 Entrevista inicial 2024-01-10 2024-01-15   2024-01-17     done\n3     Prueba técnica 2024-01-15 2024-01-25   2024-01-17 on track\n4 Llamar referencias 2024-01-15 2024-01-16   2024-01-17     done\n5   Entrevista final 2024-01-20 2024-02-05   2024-01-17  planned\n6             Oferta 2024-02-01 2024-02-15   2024-01-17  planned\n\n\nCódigo.\n\nCódigotasks |&gt; ggplot(aes(x = start, xend = end, y = task, yend = task, color = status)) + \n  geom_segment(size = 6) +\n  scale_color_manual(values = c(\"on track\" = \"lightgreen\", \n                                \"delayed\" = \"yellow3\", \n                                \"planned\" = \"lightblue1\", \n                                \"done\" = \"grey\")) +\n  labs(title = \"Proceso de selección de personal\",\n       x = \"Fecha inicio de la tarea\",\n       y = \"Fase del proceso\",\n       color = \"Status\") +\n  theme_minimal() + geom_vline(xintercept = as.numeric(as.Date(\"2024-01-17\")), linetype=\"dotted\", \n                color = \"black\", size=0.5) + \n  geom_text(x=as.numeric(as.Date(\"2024-01-17\")), y=1.5, label=Sys.Date(),\n            angle=90, color = \"darkgrey\", size=3)"
  },
  {
    "objectID": "src/grafico_radar.html",
    "href": "src/grafico_radar.html",
    "title": "Gráfico de Radar o Araña",
    "section": "",
    "text": "Librerías específicas.\n\nCódigolibrary(fmsb)\n\n\nDatos.\n\nCódigodf &lt;- as.data.frame(matrix(USAccDeaths, ncol = 12, byrow = TRUE))\ncolnames(df) &lt;- month.abb\nrownames(df) &lt;- seq(start(USAccDeaths)[1], end(USAccDeaths)[1])\n\n\n\nCódigo# Es recomendable incluir una primera fila con el máximo a mostrar en el gráfico y una segunda línea con el mínimo a mostrar en el gráfico\ndf &lt;- rbind(rep(plyr::round_any(max(df), 100, f = ceiling), ncol(df)),\n              rep(plyr::round_any(min(df), 1000, f = floor), ncol(df)),\n            df)\n\n\nCódigo.\n\nCódigo# La función radarchart no tiene un argumento para cambiar el color del fondo del panel\npar(bg = \"#f2feff\")\n\n# El gráfico no abarca todo el panel. Pequeño truco para hacer que el gráfico parezca más grande\n# (Al final no lo incliyo porque relleno ese espacio con el título del gráfico)\npar(mar = c(2, 2, 2, 2))\n\n# Defino paleta de colores\npaleta_colores &lt;- paletteer_d(\"ggthemes::wsj_colors6\")\n\n\n\nCódigodf |&gt; as.data.frame() |&gt;\n  radarchart(axistype = 2,  # Tipo de ejes\n             maxmin = TRUE,  # Incluir los valores máximo y mínimo del dataser\n             title = \"Serie temporal de muertes accidentales en EE.UU.\",\n             \n             # Tamaño de las labels de los vértices del polígono\n             vlcex = 1,\n             \n             # Tamaño de las valores de los vértices del polígono\n             palcex=0.6,\n             # Colores para las líneas de las series\n             pcol = paleta_colores,\n             \n             # Colores con transparencia para las áreas de las series\n             pfcol = alpha(paleta_colores, 0.05), \n             \n             # Parámetros de la cuadrícula\n             cglcol = \"skyblue\",  # Color de la cuadrícula\n             cglty = 1,  # Tipo de línea de la cuadrícula\n             axislabcol = \"blue\",  # Color de las etiquetas de los ejes\n             #caxislabels = seq(0, 20, 5),  # Etiquetas de los ejes\n             cglwd = 0.8) # Ancho de la línea de la cuadrícula\n\n# Añadir título y subtítulo\ntitle(#main = \"\",\n      sub = \"Se muestran los años de 1973 a 1978\",\n      line = 1)  # Ajusta la posición del título y subtítulo\n\n\n# Añadir la leyenda al gráfico\nlegend(\"right\",\n       legend = rownames(df)[-c(1,2)],  # Texto de la leyenda\n       bty = \"n\",  # Sin caja alrededor de la leyenda\n       pch = 20,  # Tipo de símbolo en la leyenda\n       col = alpha(paleta_colores, 0.7),  # Colores de la leyenda\n       text.col = \"grey25\",  # Color del texto de la leyenda\n       pt.cex = 1,  # Tamaño de los puntos en la leyenda\n       cex = 0.8,  # Tamaño del texto de la leyenda\n       #x.intersp = 0.1,  # Espaciado horizontal entre símbolos y texto\n       #y.intersp = 0.1,  # Espaciado vertical entre líneas de la leyenda\n       title = \"Años\",  # Título de la leyenda\n       title.cex = 0.9)  # Tamaño del texto del título de la leyenda"
  },
  {
    "objectID": "src/mapas.html",
    "href": "src/mapas.html",
    "title": "Mapa iteractivo",
    "section": "",
    "text": "https://github.com/CSSEGISandData/COVID-19?tab=readme-ov-file\n\nCódigolibrary(leaflet)\nlibrary(dplyr)\nlibrary(sf)\nlibrary(readr)\n\n\n\nCódigo# Datos ficticios de COVID-19 por provincias en España\ncovid_data &lt;- data.frame(\n  provincia = c(\"Madrid\", \"Barcelona\", \"Valencia\", \"Sevilla\", \"Zaragoza\"),\n  lat = c(40.4168, 41.3851, 39.4699, 37.3891, 41.6488),\n  lon = c(-3.7038, 2.1734, -0.3763, -5.9845, -0.8891),\n  casos = c(500000, 450000, 200000, 180000, 150000)\n)\n\n\n\nCódigo# Crear el mapa interactivo\nleaflet(covid_data) %&gt;%\n  addTiles() %&gt;%  # Añadir el fondo del mapa\n  addCircleMarkers(\n    ~lon, ~lat,  # Coordenadas\n    radius = ~sqrt(casos) / 1000,  # Tamaño del círculo proporcional al número de casos\n    color = \"red\",\n    fillColor = \"red\",\n    fillOpacity = 0.7,\n    popup = ~paste0(\"&lt;strong&gt;Provincia: &lt;/strong&gt;\", provincia,\n                    \"&lt;br&gt;&lt;strong&gt;Casos: &lt;/strong&gt;\", casos)\n  ) %&gt;%\n  addLegend(\n    position = \"bottomright\",\n    title = \"Número de Casos\",\n    values = ~casos,\n    colors = c(\"red\",\"yellow\"),\n    labels = c(\"Menos\", \"Más\"),\n    opacity = 0.7\n  ) %&gt;%\n  setView(lng = -3.7038, lat = 40.4168, zoom = 6)  # Centrar el mapa en España"
  },
  {
    "objectID": "src/geolocalizacion.html#polígonos",
    "href": "src/geolocalizacion.html#polígonos",
    "title": "Geovisualización",
    "section": "Polígonos",
    "text": "Polígonos\nDatos\nEl Gobierno de España pone a disposición pública bases de datos de las divisiones administrativas de España que podemos descargar en formato SHP.\n\nUna vez que tenemos claro qué tipo de información queremos, realizamos la búsqueda por listado y la añadimos en la cesta de descargas y a continuación iniciamos la descarga.\n\n\nCódigor_provinciales &lt;- st_read(\"../data/lineas_limite/SHP_ETRS89/recintos_provinciales_inspire_peninbal_etrs89/recintos_provinciales_inspire_peninbal_etrs89.shp\")\n## Reading layer `recintos_provinciales_inspire_peninbal_etrs89' from data source \n##   `C:\\Users\\MarioC\\Documents\\GitHub\\dataviz\\data\\lineas_limite\\SHP_ETRS89\\recintos_provinciales_inspire_peninbal_etrs89\\recintos_provinciales_inspire_peninbal_etrs89.shp' \n##   using driver `ESRI Shapefile'\n## Simple feature collection with 51 features and 9 fields\n## Geometry type: MULTIPOLYGON\n## Dimension:     XY\n## Bounding box:  xmin: -9.301516 ymin: 35.17045 xmax: 4.327785 ymax: 43.79238\n## Geodetic CRS:  ETRS89\n\n\n\nCódigoggplot(r_provinciales) +\n  geom_sf()"
  },
  {
    "objectID": "src/geolocalizacion.html#relleno-de-polígonos",
    "href": "src/geolocalizacion.html#relleno-de-polígonos",
    "title": "Geovisualización",
    "section": "Relleno de polígonos",
    "text": "Relleno de polígonos\nDatos\n\nCódigo# Creamos datos ficticios de conversión media por  recinto y población\nr_provinciales &lt;- r_provinciales |&gt; mutate(conversion = rnorm(dim(r_provinciales)[1], mean=0.15, sd=0.09),\n                                           conversion = conversion - min(conversion),\n                                           poblacion = exp(conversion+1)*100000)\n\n\n\nCódigo# Creamos datos ficticios de conversión media por  recinto y población\nr_provinciales &lt;- r_provinciales |&gt; mutate(conversion = rbeta(dim(r_provinciales)[1], 2, 100),\n                                           poblacion = round(conversion*10^8))\n\n\nObjetivo. Resaltar la distribución de la población en las regiones/polígonos a través de una escala cromática.\n\nCódigor_provinciales |&gt; \nggplot(aes(fill = poblacion)) +\n  geom_sf()+\n  scale_fill_viridis_c(trans = \"identity\", alpha = 0.4, labels = unit_format(unit = \"personas\", scale = 1)) + \n  labs(fill=\"Población\") + \n  theme_minimal()\n\n\n\n\nObjetivo. Resaltar la distribución del logaritmo de la población en las regiones/polígonos a través de una escala cromática.\n\nCódigor_provinciales |&gt; \nggplot(aes(fill = poblacion)) +\n  geom_sf()+\n  scale_fill_viridis_c(trans = \"log\", alpha = 0.4, labels = number) +\n  labs(fill=\"Logaritmo de la población\") + \n  theme_minimal()\n\n\n\n\nObjetivo. Resaltar la distribución inversa de la población en las regiones/polígonos a través de una escala cromática.\n\nCódigor_provinciales |&gt; \nggplot(aes(fill = poblacion)) +\n  geom_sf()+\n  scale_fill_viridis_c(trans = \"reverse\", alpha = 0.4) + \n  theme_minimal()"
  },
  {
    "objectID": "src/geolocalizacion.html#figuras-sobre-el-centroide",
    "href": "src/geolocalizacion.html#figuras-sobre-el-centroide",
    "title": "Geovisualización",
    "section": "Figuras sobre el centroide",
    "text": "Figuras sobre el centroide\nObjetivo. Destacar dos la distribución inversa de la población en las regiones/polígonos a través de una escala cromática.\n\nCódigor_provinciales |&gt; \nggplot() +\n  geom_sf()+\n  geom_point(aes(color = conversion, size = poblacion, geometry = geometry),\n            stat = \"sf_coordinates\") + \n  scale_color_gradientn(colours=rev(magma(52)),\n                       name=\"Conversión\",\n                       na.value = \"grey100\") + \n  scale_size_continuous(labels = number, guide = guide_legend(reverse = TRUE)) +\n  labs(size=\"Población\") + \n  theme_minimal()"
  },
  {
    "objectID": "src/geolocalizacion.html#porcentaje-de-relleno-del-polígono",
    "href": "src/geolocalizacion.html#porcentaje-de-relleno-del-polígono",
    "title": "Geovisualización",
    "section": "Porcentaje de relleno del polígono",
    "text": "Porcentaje de relleno del polígono\n\nCódigobbox &lt;- st_bbox(r_provinciales |&gt; filter(NAMEUNIT==\"Madrid\"))\nbbox &lt;- st_bbox(r_provinciales)\n\ncupo &lt;- 0.5\n\nthisBBox &lt;- bbox\nthisBBox['ymax'] &lt;- thisBBox$ymin + (thisBBox$ymax - thisBBox$ymin) * cupo\n\nthisSubarea &lt;- st_crop(r_provinciales$geometry, y=thisBBox)\nthisArea &lt;- st_area(thisSubarea)\n\n\n\nCódigoplot(r_provinciales$geometry)\nplot(thisSubarea, max.plot=1, add=T, col='orange') #, border=NA\n\n\n\n\n\nCódigor_provinciales_01 &lt;- r_provinciales |&gt; filter(NAMEUNIT==\"Madrid\")\nbbox &lt;- st_bbox(r_provinciales_01)\n\ncupo &lt;- 0.2\n\nthisBBox &lt;- bbox\nthisBBox['ymax'] &lt;- thisBBox$ymin + (thisBBox$ymax - thisBBox$ymin) * cupo\n\nthisSubarea &lt;- st_crop(r_provinciales_01$geometry, y=thisBBox)\nthisArea &lt;- thisSubarea\n\n\n\nCódigoplot(r_provinciales_01$geometry)\nplot(thisSubarea, max.plot=1, add=T, col='lightgreen') #, border=NA"
  },
  {
    "objectID": "src/dispersiones.html",
    "href": "src/dispersiones.html",
    "title": "Sin nombre todavía",
    "section": "",
    "text": "Datos\nEl conjunto de datos Used Car Price Prediction Dataset es una colección completa de información extraída de la página web del mercado automovilístico https://www.cars.com. Este dataset comprende 4.009 puntos de datos, cada uno de los cuales representa una lista de vehículos única, e incluye nueve características distintas que brindan información valiosa sobre el mundo de los automóviles.\nhttps://www.kaggle.com/datasets/taeefnajib/used-car-price-prediction-dataset/data\n\nCódigoused_cars &lt;- read_csv(\"../data/used_cars.csv\")\n\n\n\nCódigoused_cars &lt;- used_cars |&gt; select(milage, price) |&gt; mutate(milage =  as.numeric(gsub(\"[^0-9]\", \"\", milage)),\n                                                          price = as.numeric(gsub(\"[$,]\", \"\", price)))\n\n\nLibrerías específicas.\nCódigo.\n\nCódigoused_cars |&gt; \nggplot(aes(x=milage, y=price)) + \ngeom_point()\n\n\n\n\n\nCódigoused_cars |&gt; \nggplot(aes(x=milage, y=log(price))) + \ngeom_point()\n\n\n\n\n\nCódigoused_cars |&gt; \nggplot(aes(x=as.factor(floor(milage / 10000) * 10000), y=price, fill=cut(milage, breaks = c(0, 29999, 69999, 199999, 999999999), labels = c(\"Bajo\", \"Medio\", \"Alto\", \"Muy alto\")))) + \n  geom_boxplot() + \n  ylim(0, 100000) + \n  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +\n  scale_fill_manual(values = c(\"lightblue\", \"lightgreen\", \"lightpink\", \"orange\")) + \n  labs(x=\"Kilometraje\", y=\"Precio\", title= \"Relación entre Kilometraje y Precio\", fill=\"Intervalo kilometraje\")\n\n\n\n\n\nCódigoused_cars |&gt; \nggplot(aes(x=as.factor(floor(milage / 10000) * 10000), y=price, fill=ifelse(milage &gt; median(milage), \"Above\", \"Below\"))) + \n  geom_boxplot() + \n  ylim(0, 100000) + \n  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +\n  scale_fill_manual(values = c(\"Below\" = \"lightblue\", \"Above\" = \"lightcoral\")) +\n  labs(x=\"Kilometraje\", y=\"Precio\", title= \"Precios por Encima o Debajo de la Mediana\", fill=\"\")\n\n\n\n\n\nCódigoused_cars |&gt; \nggplot(aes(x=as.factor(floor(price / 10000) * 10000), y=milage, fill=ifelse(price &gt; median(price), \"Above\", \"Below\"))) + \n  geom_boxplot() + \n  ylim(0, 100000) + \n  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +\n  scale_fill_manual(values = c(\"Below\" = \"lightblue\", \"Above\" = \"lightcoral\")) +\n  labs(x=\"Kilometraje\", y=\"Precio\", title= \"Precios por Encima o Debajo de la Mediana\", fill=\"\")"
  },
  {
    "objectID": "src/otros.html",
    "href": "src/otros.html",
    "title": "Otros",
    "section": "",
    "text": "———–\nGráfico de mosaico\n\nCódigolibrary(vcd)\n\n\n\nCódigomosaic(~ Class + Survived, data = Titanic, shade = TRUE, legend = TRUE)\n\n\n\n\n\nCódigolibrary(ggplot2)\nlibrary(dplyr)\n\n\n\nCódigo# Crear un marco de datos con categorías\ndata &lt;- data.frame(\n  Categoria1 = rep(c(\"A\", \"B\", \"C\"), each = 3),\n  Categoria2 = rep(c(\"X\", \"Y\", \"Z\"), times = 3),\n  Count = c(10, 20, 30, 5, 15, 25, 20, 10, 5)\n)\n\n# Calcular proporciones\ndata &lt;- data %&gt;%\n  group_by(Categoria1) %&gt;%\n  mutate(Proporcion = Count / sum(Count)) %&gt;%\n  ungroup()\n\n# Crear el gráfico de mosaico\nggplot(data, aes(x = Categoria1, y = Count, fill = Categoria2)) +\n  geom_tile(aes(height = Count)) +\n  labs(title = \"Gráfico de Mosaico\",\n       x = \"Categoría 1\",\n       y = \"Proporción\",\n       fill = \"Categoría 2\") +\n  theme_minimal()\n\n\n\nCódigo# Crear el gráfico de mosaico\nggplot(data, aes(x = Categoria1, y = Proporcion, fill = Categoria2)) +\n  geom_tile(aes(height = Proporcion)) +\n  labs(title = \"Gráfico de Mosaico\",\n       x = \"Categoría 1\",\n       y = \"Proporción\",\n       fill = \"Categoría 2\") +\n  theme_minimal()\n\n\n\n\n\nCódigo#ggplot(data = fly) +\n#  geom_mosaic(aes(x=product(do_you_recline), fill = do_you_recline, \n#                  conds = product(rude_to_recline))) +\n#  labs(title='f(do_you_recline | rude_to_recline)')\n\n\nMapa de calor iteractivo\n\nCódigo# Librerías\nlibrary(ggplot2)\nlibrary(reshape2)\nlibrary(heatmaply)\n\n# Datos\ndata &lt;- cor(mtcars)\n\n# Mapa de calor\nheatmaply(data, k_row = 3, k_col = 2, main = \"Correlación entre variables de mtcars\")\n\n\n\n\n\nTree map\n\nCódigo# Librerías\nlibrary(ggplot2)\nlibrary(treemapify)\n\n# Datos\ndata &lt;- data.frame(\n  category = c(\"A\", \"B\", \"C\", \"D\"),\n  value = c(40, 30, 20, 10)\n)\n\n# Gráfico de árbol\nggplot(data, aes(area = value, fill = category, label = category)) +\n  geom_treemap() +\n  geom_treemap_text(colour = \"white\", place = \"centre\") +\n  labs(title = \"Distribución de categorías\")\n\n\n\n\nMapa coroplético\n\nCódigo# Librerías\nlibrary(ggplot2)\nlibrary(maps)\n\n# Datos\ndata &lt;- map_data(\"state\")\ndata$rate &lt;- runif(nrow(data), min = 0, max = 1)\n\n# Mapa coroplético\nggplot(data, aes(long, lat, group = group)) +\n  geom_polygon(aes(fill = rate), color = \"white\") +\n  scale_fill_continuous(low = \"white\", high = \"blue\") +\n  labs(title = \"Tasa aleatoria por estado\")\n\n\n\n\nGráfico de Sankey\n\nCódigo# Librerías\nlibrary(networkD3)\n\n# Datos\nnodes &lt;- data.frame(name = c(\"A\", \"B\", \"C\", \"D\"))\nlinks &lt;- data.frame(\n  source = c(0, 1, 1, 2, 3),\n  target = c(1, 2, 3, 3, 2),\n  value = c(10, 20, 30, 40, 50)\n)\n\n# Gráfico de Sankey\nsankeyNetwork(Links = links, Nodes = nodes, Source = \"source\", Target = \"target\",\n              Value = \"value\", NodeID = \"name\", fontSize = 12)\n\n\n\n\n\n\nCódigo# Librerías\nlibrary(fmsb)\n\n# Datos\ndata &lt;- as.data.frame(matrix(sample(2:20, 10, replace = TRUE), ncol = 5))\ncolnames(data) &lt;- c(\"A\", \"B\", \"C\", \"D\", \"E\")\n\n# Gráfico de radar\n# radarchart(data, axistype = 1, pcol = \"blue\", pfcol = scales::alpha(\"blue\", 0.5))\n\n\nGráfico de Mariposa (Population Pyramid)\n\nCódigo# Librerías\nlibrary(ggplot2)\n\n# Datos\ndata &lt;- data.frame(\n  age = rep(1:10, 2),\n  count = c(10, 20, 30, 40, 50, 40, 30, 20, 10, 5, 15, 25, 35, 45, 55, 45, 35, 25, 15, 10),\n  gender = rep(c(\"Male\", \"Female\"), each = 10)\n)\n\n# Gráfico de mariposa\nggplot(data, aes(x = age, y = count, fill = gender)) +\n  geom_bar(stat = \"identity\", position = \"dodge\") +\n  coord_flip() +\n  labs(title = \"Pirámide de población\")\n\n\n\n\nGráfico de burbujas\n\nCódigo# Librerías\nlibrary(ggplot2)\n\n# Datos\ndata &lt;- data.frame(\n  x = rnorm(100),\n  y = rnorm(100),\n  size = rnorm(100, mean = 5, sd = 2)\n)\n\n# Gráfico de burbujas\nggplot(data, aes(x = x, y = y, size = size)) +\n  geom_point(alpha = 0.5) +\n  labs(title = \"Gráfico de burbujas\")"
  }
]