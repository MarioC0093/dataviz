---
title: "Dataviz"
author: "Mario Camacho"
date-modified: last-modified
date-format: "DD MMMM YYYY"
lang: es

categories: ["Portafolio", "Dataviz"]

description: "Un portafolio que muestra algunas de mis visualizaciones y sirve de plantilla para toda persona que necesite ideas para una representación de sus datos."

abstract: |
  Una visualización de datos correcta puede expresar de forma resumida y clara gran cantidad de información, ayudando a interpretar y asimilar la información más facilmente. 

keywords: ["portafolio", "[tu área de especialización]", "proyectos", "habilidades", "experiencia"]

format:
  html:
    code-link: true
    toc: TRUE
    toc-title: "Ejemplos"
    toc-location: left
    toc-expand: TRUE
    number-sections: true

editor: visual
page-layout: full
knitr:
  opts_chunk: 
    R.options:
      width: 110
code-fold: true
warning: false
---

```{css echo=FALSE}
h1 {
  color: black;
  background: linear-gradient(to right, lightgrey, powderblue);
}

h2 {
  color: blue;
}
```

<h3 style="background: linear-gradient(to right, white, lightgrey); color: lightblue;">

Repositorio Git:</h3>

<https://github.com/MarioC0093/dataviz/blob/main/README.md>

<h3 style="background: linear-gradient(to right, white, lightgrey); color: lightblue;">

Librerías comunes:</h3>

```{r}
#| code-fold: false
library(tidyverse)
library(ggplot2)
library(glue)
```

# Gráfico de Gannt

Gráfico de Gannt de un proceso de selección.

Se tiene la fecha de inicio y de finalización de cada tarea. Para el status de cada tarea se compara la fecha actual con la fecha de finalización de la tarea.

[**Datos**]{.underline}

```{r}
tasks <- 
  data.frame(
    task = factor(c("Revisión de CV",
                    "Entrevista inicial",
                    "Prueba técnica",
                    "Llamar referencias",
                    "Entrevista final",
                    "Oferta"),
                  levels = c("Revisión de CV",
                             "Entrevista inicial",
                             "Prueba técnica",
                             "Llamar referencias",
                             "Entrevista final",
                             "Oferta")),
    start = as.Date(c("2024-01-01",
                      "2024-01-10",
                      "2024-01-15",
                      "2024-01-15",
                      "2024-01-20",
                      "2024-02-01")),
    end = as.Date(c("2024-01-07",
                    "2024-01-15",
                    "2024-01-25",
                    "2024-01-16",
                    "2024-02-05",
                    "2024-02-15"))
)

tasks <- tasks %>%
  mutate(
    # Sustituir la fecha por Sys.Date()
    fecha_actual = "2024-01-17",
    status = case_when(
      start > "2024-01-17" ~ "planned",
      start < "2024-01-17" & end > "2024-01-17" ~ "on track",
      start < "2024-01-17" & end < "2024-01-17" ~ "done",
      TRUE ~ "delayed")
  ) |> arrange(start)

tasks
```

[**Código.**]{.underline}

```{r}
tasks |> ggplot(aes(x = start, xend = end, y = task, yend = task, color = status)) + 
  geom_segment(size = 6) +
  scale_color_manual(values = c("on track" = "lightgreen", 
                                "delayed" = "yellow3", 
                                "planned" = "lightblue1", 
                                "done" = "grey")) +
  labs(title = "Proceso de selección de personal",
       x = "Fecha inicio de la tarea",
       y = "Fase del proceso",
       color = "Status") +
  theme_minimal() + geom_vline(xintercept = as.numeric(as.Date("2024-01-17")), linetype="dotted", 
                color = "black", size=0.5) + 
  geom_text(x=as.numeric(as.Date("2024-01-17")), y=1.5, label=Sys.Date(),
            angle=90, color = "darkgrey", size=3)
```

# Word cloud

Word cloud de las primeras diez mil palabras del Quijote.

[**Librerías específicas.**]{.underline}

```{r}
library(stringr)
library(wordcloud)
library(tm)
library(stopwords)
```

[**Datos.**]{.underline}

Fuente: <https://www.gutenberg.org/cache/epub/2000/pg2000.txt>

[**Código.**]{.underline}

```{r}
# Leo el Quijote
quijote <- readLines("data/quijote.txt", encoding = "UTF-8")

# Concateno todas las líneas en una sola cadena
quijote <- paste(quijote, collapse = " ")

# Convierto el Quijote a minúsculas, elimino caracteres especiales
quijote <- tolower(quijote)
quijote <- str_replace_all(quijote, "[^a-záéíóúüñ]", " ")

# Dividir el texto en palabras y eliminar stop words
quijote_words <- unlist(strsplit(quijote, "\\s+"))
quijote_words <- quijote_words[!quijote_words %in% tm::stopwords("spanish")] # análogo: quijote_words <- quijote_words[!quijote_words %in% stopwords::stopwords("spanish")]
quijote_words <- quijote_words[!quijote_words %in% tm::stopwords("spanish")]

# Filtrar las palabras vacías (espacios en blanco) y obtener las primeras 1000 palabras
quijote_words <- quijote_words[quijote_words != ""]
first_1000_words <- quijote_words[1:10000]
```

```{r}
wordcloud(words = first_1000_words, min.freq = 10, colors = brewer.pal(8, "Dark2"))
```

# Parlamento

Se representa los votos recibidos por cada partido político en las elecciones de noviembre de 2019.

El número de escaños representado para cada partido político es proporcional a los votos recibidos y no representa el método D’Hondt.

[**Librerías específicas.**]{.underline}

```{r}
library(ggparliament)
```

[**Datos.**]{.underline}

```{r}
datos_elecciones <- read_csv(file = "data/datos_elecciones_brutos.csv")
datos_elecciones <- datos_elecciones |> filter(anno==max(anno)) |> filter(mes==max(mes))

# Elimino variables sin información
cols_sin_informacion <- datos_elecciones |> select(1:15) |>
  summarise(across(everything(), n_distinct)) |> pivot_longer(cols = everything()) |> 
  filter(value==1) |> select(name) |> pull()

datos_elecciones <- datos_elecciones |> select(-all_of(cols_sin_informacion))

# Pivoto los datos
datos_elecciones <- datos_elecciones |>
  pivot_longer(cols = -c(0:votos_candidaturas),
               names_to = "partido_politico",
               values_to = "votos") |> 
  drop_na(votos)

# Creo las siglas de cada partido y agrupo los votos por las siglas
source("scr/mutate_siglas.R")
datos_elecciones <- mutate_siglas(datos_elecciones)

datos_elecciones <- datos_elecciones |>
  summarise(votos = sum(votos), .by=everything()[! everything() %in% c('votos')])

datos_elecciones <- datos_elecciones |>
  mutate(siglas = fct_reorder(siglas, votos, .fun = sum))
```

```{r}
# Defino la paleta de colores
datos_elecciones <- datos_elecciones |>
  mutate(color_politico = case_when(siglas == "PP" ~ "#3399FF",
                         siglas == "PSOE" ~ "#F6350B",
                         siglas == "C's" ~ "#FF5824",
                         siglas == "PNV" ~ "#008135",
                         siglas == "BNG" ~ "#76b3dd",
                         siglas == "COMPROMÍS" ~ "#de6c25",
                         siglas == "CiU" ~ "#FF0000",
                         siglas == "UP" ~ "#6D50B3",
                         siglas == "ERC" ~ "#ffbf41",
                         siglas == "EH - BILDU" ~ "#00bda1",
                         siglas == "MÁS PAÍS" ~ "#E61455",
                         siglas == "VOX" ~ "#73B446",
                         TRUE ~ "#462B25"))
```

[**Código.**]{.underline}

```{r}
#| out-width: 80%
parlamento <- datos_elecciones |> 
  summarise(votos=sum(votos), .by = c(siglas, color_politico))

parlamento <- parlamento |> 
  mutate(asientos = round(350*votos/sum(votos))) |> 
  select(-votos)

semicircle <- parliament_data(election_data = parlamento,
                                 type = "semicircle", # Tipo de parlamento
                                 parl_rows = 7,      # Número de filas del parlamento
                                 party_seats = parlamento$asientos) # Asientos por partido

semi2 <- ggplot(semicircle, aes(x = x, y = y, colour = siglas)) +
  geom_parliament_seats() + 
  theme_ggparliament() +
  labs(title = "Segundas elecciones de 2.019", x = "", y = "") +
  scale_colour_manual(values = semicircle$color_politico, 
                      limits = semicircle$siglas) + 
  theme(legend.position="bottom")

semi2
```

# Gatitos
```{r}
# install.packages("Ecdat")
library(Ecdat)
# install.packages("tidyverse")
library(tidyverse)
# install.packages("gganimate")
library(gganimate)
# install.packages("remotes")
# remotes::install_github("R-CoderDotCom/ggcats@main")
library(ggcats)

# Data frame
 dat <-
   incomeInequality %>%
   select(Year, P99, median) %>%
   rename(income_median = median,
          income_99percent = P99) %>%
   pivot_longer(cols = starts_with("income"),
                names_to = "income",
                names_prefix = "income_")

# Gatos para cada línea
dat$cat <- rep(NA, 132)
dat$cat[which(dat$income == "median")] <- "nyancat"
dat$cat[which(dat$income == "99percent")] <- rep(c("pop_close", "pop"), 33)

# Animación
ggplot(dat, aes(x = Year, y = value, group = income, color = income)) +
   geom_line(size = 2) +
   ggtitle("ggcats, a core package of the memeverse") +
   geom_cat(aes(cat = cat), size = 5) +
   xlab("Cats") +
   ylab("Cats") +
   theme(legend.position = "none",
         plot.title = element_text(size = 20),
         axis.text = element_blank(),
         axis.ticks = element_blank()) +
   transition_reveal(Year)
```

### -----------

# Gráfico de mosaico

```{r}
library(vcd)
```

```{r}
mosaic(~ Class + Survived, data = Titanic, shade = TRUE, legend = TRUE)
```

```{r}
library(ggplot2)
library(dplyr)
```

```{r}
# Crear un marco de datos con categorías
data <- data.frame(
  Categoria1 = rep(c("A", "B", "C"), each = 3),
  Categoria2 = rep(c("X", "Y", "Z"), times = 3),
  Count = c(10, 20, 30, 5, 15, 25, 20, 10, 5)
)

# Calcular proporciones
data <- data %>%
  group_by(Categoria1) %>%
  mutate(Proporcion = Count / sum(Count)) %>%
  ungroup()

# Crear el gráfico de mosaico
ggplot(data, aes(x = Categoria1, y = Count, fill = Categoria2)) +
  geom_tile(aes(height = Count)) +
  labs(title = "Gráfico de Mosaico",
       x = "Categoría 1",
       y = "Proporción",
       fill = "Categoría 2") +
  theme_minimal()

# Crear el gráfico de mosaico
ggplot(data, aes(x = Categoria1, y = Proporcion, fill = Categoria2)) +
  geom_tile(aes(height = Proporcion)) +
  labs(title = "Gráfico de Mosaico",
       x = "Categoría 1",
       y = "Proporción",
       fill = "Categoría 2") +
  theme_minimal()

```

```{r}
#ggplot(data = fly) +
#  geom_mosaic(aes(x=product(do_you_recline), fill = do_you_recline, 
#                  conds = product(rude_to_recline))) +
#  labs(title='f(do_you_recline | rude_to_recline)')
```

# Mapa de calor iteractivo

```{r}
# Librerías
library(ggplot2)
library(reshape2)
library(heatmaply)

# Datos
data <- cor(mtcars)

# Mapa de calor
heatmaply(data, k_row = 3, k_col = 2, main = "Correlación entre variables de mtcars")
```

# Tree map

```{r}
# Librerías
library(ggplot2)
library(treemapify)

# Datos
data <- data.frame(
  category = c("A", "B", "C", "D"),
  value = c(40, 30, 20, 10)
)

# Gráfico de árbol
ggplot(data, aes(area = value, fill = category, label = category)) +
  geom_treemap() +
  geom_treemap_text(colour = "white", place = "centre") +
  labs(title = "Distribución de categorías")
```

# Mapa coroplético

```{r}
# Librerías
library(ggplot2)
library(maps)

# Datos
data <- map_data("state")
data$rate <- runif(nrow(data), min = 0, max = 1)

# Mapa coroplético
ggplot(data, aes(long, lat, group = group)) +
  geom_polygon(aes(fill = rate), color = "white") +
  scale_fill_continuous(low = "white", high = "blue") +
  labs(title = "Tasa aleatoria por estado")

```

# Gráfico de Sankey

```{r}
# Librerías
library(networkD3)

# Datos
nodes <- data.frame(name = c("A", "B", "C", "D"))
links <- data.frame(
  source = c(0, 1, 1, 2, 3),
  target = c(1, 2, 3, 3, 2),
  value = c(10, 20, 30, 40, 50)
)

# Gráfico de Sankey
sankeyNetwork(Links = links, Nodes = nodes, Source = "source", Target = "target",
              Value = "value", NodeID = "name", fontSize = 12)

```

# Gráfico de Radar o Araña

```{r}
# Librerías
library(fmsb)

# Datos
data <- as.data.frame(matrix(sample(2:20, 10, replace = TRUE), ncol = 5))
colnames(data) <- c("A", "B", "C", "D", "E")

# Gráfico de radar
# radarchart(data, axistype = 1, pcol = "blue", pfcol = scales::alpha("blue", 0.5))
```

```{r}
## 11. Gráfico de Radar o Araña

# Librerías
library(fmsb)

# Datos
data <- data.frame(
  A = c(10, 15, 8),
  B = c(9, 17, 6),
  C = c(12, 13, 9),
  D = c(8, 10, 14),
  E = c(15, 8, 12)
)

# Agregar las filas máximas y mínimas para escalar el gráfico
data <- rbind(rep(20, 5), rep(0, 5), data)

# Gráfico de radar
radarchart(data, axistype = 1, 
           pcol = rainbow(3), 
           pfcol = scales::alpha(rainbow(3), 0.4), 
           plwd = 2, 
           cglcol = "grey", 
           cglty = 1, 
           axislabcol = "grey", 
           caxislabels = seq(0, 20, 5), 
           cglwd = 0.8)

```

# Gráfico de Superficie

```{r}
# Librerías
library(plotly)

# Datos
x <- seq(-10, 10, length.out = 100)
y <- seq(-10, 10, length.out = 100)
z <- outer(x, y, function(x, y) cos(sqrt(x^2 + y^2)))

# Gráfico de superficie
plot_ly(x = ~x, y = ~y, z = ~z, type = "surface") %>%
  layout(title = "Gráfico de superficie")
```

# Gráfico de Mariposa (Population Pyramid)

```{r}
# Librerías
library(ggplot2)

# Datos
data <- data.frame(
  age = rep(1:10, 2),
  count = c(10, 20, 30, 40, 50, 40, 30, 20, 10, 5, 15, 25, 35, 45, 55, 45, 35, 25, 15, 10),
  gender = rep(c("Male", "Female"), each = 10)
)

# Gráfico de mariposa
ggplot(data, aes(x = age, y = count, fill = gender)) +
  geom_bar(stat = "identity", position = "dodge") +
  coord_flip() +
  labs(title = "Pirámide de población")
```

# Gráfico de burbujas

```{r}
# Librerías
library(ggplot2)

# Datos
data <- data.frame(
  x = rnorm(100),
  y = rnorm(100),
  size = rnorm(100, mean = 5, sd = 2)
)

# Gráfico de burbujas
ggplot(data, aes(x = x, y = y, size = size)) +
  geom_point(alpha = 0.5) +
  labs(title = "Gráfico de burbujas")
```
